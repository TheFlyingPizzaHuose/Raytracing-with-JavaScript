<!DOCTYPE html>

<html>
<body>

<canvas id="screen" width="720" height="404" style="border:1px solid #000000;">
Your browser does not support the HTML canvas tag.
</canvas>

<script>

//creates canvas(screen) object
var c = document.getElementById("screen");
var ctx = c.getContext("2d");

//draw image on screen function 
function display(image){
	var canvasImage = ctx.createImageData(c.width, c.height);
	canvasImage.data.set(image);
	ctx.putImageData(canvasImage, 0, 0);
}

//fills image data array with single color
function fillScreen(R, G, B){
	var c = document.getElementById("screen");
	var result = [];
	for (h = 0; h < c.height; h++){
		for (w = 0; w < c.width; w++){
			var i = ((h*c.width) + w) * 4;
			temp[i    ] = R;
			temp[i + 1] = G;
			temp[i + 2] = B;
			temp[i + 3] = 255;
		}
	}
	return result;
}

//degrees to radians
function degToArc(degree){
	var result = Math.PI*degree/180;
	return result;
}

//fast sine, tangent and cosine initilization
function fastSinCosTanInitialize(resolutionX3, fov2){
	var result = [[], [], []];
	var accuracy = fov2/resolutionX3
	for(i = 0; i <= Math.round(360/accuracy); i++){
		
		//calculates sin
		result[0][i] = parseFloat(Math.sin(degToArc(i*accuracy)).toFixed(5));

		//calculates cos
		result[1][i] = parseFloat(Math.cos(degToArc(i*accuracy)).toFixed(5));

		//calculates tan^-1 fraction
		result[2][i] = parseFloat((result[1][i]/result[0][i]).toFixed(5));
	}
	return result;
}

//fast arctangent method
function fastAtan(fraction){
	var result = 0;
	var temp = 1;
	for(i = 0; i < tanTable.length; i++){
		var temp2 = Math.abs(tanTable[i] - fraction);
		if(temp2 < temp){
			temp = temp2;
			result = (360/tanTable.length) * i;
		}	
	}
	return result;
}

//fast sine/cosine method
function fastSinCos(angle, mode){
	if(mode == 1){
		var result = table[parseInt(angle/(360/sinTable.legnth))];
	} else if (mode == 2){
		var result  = table[parseInt(angle/(360/cosTable.legnth))];
	}
	return result;
}

//calculate crpssProduct
function crossProduct(matrixV31, matrixV32){
	var cX = matrixV31[1]*matrixV32[2] - matrixV31[2]*matrixV32[1];
	var cY = matrixV31[2]*matrixV32[0] - matrixV31[0]*matrixV32[2];
	var cZ = matrixV31[0]*matrixV32[1] - matrixV31[1]*matrixV32[0];
	var result = [cX,cY,cZ];
	return result;
}

//gets distance of two points
function vectorDistance(point1, point2){
	var result = Math.sqrt(Math.pow(point1[0]-point2[0], 2) + Math.pow(point1[1]-point2[1], 2) + Math.pow(point1[2]-point2[2], 2));
	return result;
}

//parse OBJ
function parseOBJ(file){
	var result = [];
	return result;
}

//calculate normals
function calcNormals(sceneData5){
	var result = sceneData5;
	for(i = 0; i < result.length; i++){
		result[i][4] = crossProduct(result[i][2], result[i][3]);
	}
	return result;
}

//calculate midpoint of two vertecies
function midPoint(vertex1, vertex2){
	var result = [];
        for (i = 0; i < 3; i++){
                result[i] = (vertex1[i]-vertex2[i])/2
	}
	return result;
}
	
//calculate intersection spheres of each face
function calcIncSphere(sceneData6){
        var result = sceneData6;
	for (i = 0; i < result.length; i++){
		
		//gets midpoint of 2 edges of the face
		var midpointAB = midPoint(sceneData6[i][1], sceneData6[i][2]);
		var midpointBC = midPoint(sceneData6[i][2], sceneData6[i][3]);
		
		//gets vector of two edges of face assuming vertex 1 is at origin
		var edgeBCvector = [sceneData6[i][2][0] - sceneData6[i][0][0], sceneData6[i][2][1] - sceneData6[i][0][1], sceneData6[i][2][2] - sceneData6[i][0][2]];
		var edgeABvector = [sceneData6[i][1][0] - sceneData6[i][0][0], sceneData6[i][1][1] - sceneData6[i][0][1], sceneData6[i][1][2] - sceneData6[i][0][2]];
		
		//gets vector of perpendicular bisector
		var perpendicularBisectorAB = crossProduct(edgeABvector, crossProduct(edgeBCvector, edgeABvector));
		var perpendicularBisectorBC = crossProduct(crossProduct(edgeBCvector, edgeABvector), edgeBCvector);
		
		//constans for sytem of equations
		var contsA = midpointAB[0] - midpointBC[0];
		var contsB = midpointAB[1] - midpointBC[1];
		
		//Determinands
		var D = perpendicularBisectorBC[0]*perpendicularBisectorAB[1] - perpendicularBisectorAB[0]*perpendicularBisectorBC[1];
		var DJ = contsB*perpendicularBisectorBC[0] - contsA*perpendicularBisectorBC[1];
		
		//solved unknowns in system
		var d1 = D/DJ;
		
		//Intersection coordinates
		var I = midpointAB[0] + perpendicularBisectorAB[0]*d1;
		var J = midpointAB[1] + perpendicularBisectorAB[1]*d1;
		var K = midpointAB[2] + perpendicularBisectorAB[2]*d1;
		
		//Sphere radius
		var R = vectorDistance([I, J, K], sceneData6[i][1]);
		
                result[i][6] = [I, J, K, R];
	}
}

//determine closest intersection
function bounce(originV33, directionV3, sceneData4){
	var result = 0;
	return result;
}

//bounce pixels x amount of times
function rayTrace(sceneData4, numberOfBounces, width, height, fov4){
	var result = [];
	return result;
}

//render method
function render(sceneData2, cameraDirectionV32, resolutionX2, resolutionY2, fov5, cameraV33){

	if (updateScene == True){
	    //calculates normals
	    var sceneData3 = calcNormals(sceneData2);
            //calculates intersection spheres
	}

	//creates image data
	var imageData = rayTrace(sceneData3, 2, resolutionX2, resolutionY2, fov5);

	//draws image
	display(imageData);
}

//creates sine, tangent and cosine lookup tables
var tempMain = fastSinCosTanInitialize(c.width, 70);
var sinTable = tempMain[0];
var cosTable = tempMain[1];
var tanTable = tempMain[2];

//temporary variable assignments
var sceneData = []; //each element is an array with 7 elements [colorHEX, vertex1, vertex2, vertex3, normal, intersectionSphere, roughness]
var cameraDirectionV3 = [];
var cameraV3 = [0, 0, 0];
var fov = 0;

setInterval(render(sceneData, cameraDirectionV3, c.width, c.height, fov, cameraV3), 1);

</script>
</body>
</html>
